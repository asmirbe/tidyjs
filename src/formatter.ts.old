import { configManager } from './utils/config';
import { logDebug } from './utils/log';
import { alignFromKeyword, formatSimpleImport, getFromIndex, isCommentLine, isEmptyLine, sortImportNamesByLength } from './utils/misc';
import type { FormatterConfig, FormattedImportGroup } from './types';

// Types pour la nouvelle structure du parser
interface ImportSpecifier {
  type: 'named' | 'default' | 'typeNamed' | 'typeDefault' | 'sideEffect';
  source: string;
  specifiers: Array<{
    name: string;
    isType?: boolean;
  }>;
  raw: string;
  groupName: string;
  isPriority: boolean;
  appSubfolder: string | null;
}

interface ImportGroup {
  name: string;
  order: number;
  imports: ImportSpecifier[];
}

interface ParsedImports {
  groups: ImportGroup[];
  originalImports: string[];
  invalidImports: string[];
}

// Cache pour la memoization des calculs de longueur
const lengthMemoCache = new Map<string, number>();

function cleanUpLines(lines: string[]): string[] {
  const cleanedLines: string[] = [];
  let previousLine = '';
  let consecutiveEmptyLines = 0;

  for (const currentLine of lines) {
    // Ne pas ajouter de commentaires identiques à la suite
    if (isCommentLine(currentLine) && previousLine === currentLine) {
      continue;
    }

    // Gérer les lignes vides
    if (isEmptyLine(currentLine)) {
      consecutiveEmptyLines++;
      if (consecutiveEmptyLines > 1) {
        continue;
      }
    } else {
      consecutiveEmptyLines = 0;
    }

    cleanedLines.push(currentLine);
    previousLine = currentLine;
  }

  // Supprimer la dernière ligne vide si elle existe
  if (cleanedLines.length > 0 && isEmptyLine(cleanedLines[cleanedLines.length - 1])) {
    cleanedLines.pop();
  }

  // Ajouter une ligne vide finale pour séparer les imports du reste du code
  cleanedLines.push('');

  return cleanedLines;
}

function alignImportsInGroup(
  importLines: string[],
  config: FormatterConfig
): string[] {
  // Optimisation: Calculer les indices "from" en une seule passe
  const fromIndices = new Map<string, number>();
  let maxWidth = 0;

  for (const line of importLines) {
    const isMultiline = line.includes('\n');
    const fromIndex = getFromIndex(line, isMultiline);

    if (fromIndex > 0) {
      fromIndices.set(line, fromIndex);
      maxWidth = Math.max(maxWidth, fromIndex);
    }
  }

  // Aligner tous les "from" du groupe en ajoutant l'espacement configuré
  return importLines.map((line) => {
    const fromIndex = fromIndices.get(line);
    if (fromIndex !== undefined) {
      return alignFromKeyword(line, fromIndex, maxWidth, config.alignmentSpacing);
    }
    return line;
  });
}

function alignImportsBySection(
  formattedGroups: FormattedImportGroup[],
  config: FormatterConfig = configManager.getFormatterConfig()
): string[] {
  const resultLines: string[] = [];
  const seenGroups = new Set<string>();

  for (const group of formattedGroups) {
    const { groupName, importLines } = group;

    // Si ce groupe a déjà été traité, ignorer son commentaire
    if (seenGroups.has(groupName)) {
      logDebug(`Groupe dupliqué ignoré: ${groupName}`);
      continue;
    }

    seenGroups.add(groupName);

    // Ajouter le commentaire de groupe normalisé
    resultLines.push(`// ${groupName}`);

    // Aligner les imports au sein du groupe
    const alignedImports = alignImportsInGroup(importLines, config);

    // Ajouter les imports alignés
    resultLines.push(...alignedImports);

    // Ajouter une ligne vide après chaque groupe
    resultLines.push('');
  }

  // Nettoyage des lignes vides et commentaires dupliqués
  return cleanUpLines(resultLines);
}

function getMemoizedLength(importItem: ImportSpecifier): number {
  // Créer une clé unique basée sur les propriétés de l'import
  const cacheKey = `${importItem.source}_${importItem.type}_${importItem.specifiers.join(',')}`;

  if (lengthMemoCache.has(cacheKey)) {
    return lengthMemoCache.get(cacheKey)!;
  }

  const length = calculateEffectiveLengthForSorting(importItem);
  lengthMemoCache.set(cacheKey, length);
  return length;
}

function calculateEffectiveLengthForSorting(importItem: ImportSpecifier): number {
  const { type, specifiers } = importItem;

  // Import par défaut sans imports nommés
  if (type === 'default') {
    return specifiers[0].name.length;
  }

  // Imports nommés sans import par défaut
  if (type === 'named' && specifiers.length > 0) {
    // Optimisation: Éviter de mapper puis de prendre le max
    let maxLength = 0;
    for (const spec of specifiers) {
      maxLength = Math.max(maxLength, spec.name.length);
    }
    return maxLength;
  }

  // Import de type par défaut
  if (type === 'typeDefault') {
    return specifiers[0].name.length;
  }

  // Import de type nommé
  if (type === 'typeNamed' && specifiers.length > 0) {
    let maxLength = 0;
    for (const spec of specifiers) {
      maxLength = Math.max(maxLength, spec.name.length);
    }
    return maxLength;
  }

  // Cas par défaut (side-effect imports)
  return 0;
}

const getEffectiveLengthForSorting = getMemoizedLength;

function formatDefaultImport(
  defaultSpec: { name: string; isType?: boolean },
  moduleName: string,
  isTypeImport: boolean
): string {
  const typePrefix = (defaultSpec.isType || isTypeImport) ? 'type ' : '';
  return `import ${typePrefix}${defaultSpec.name} from '${moduleName}';`;
}

function formatNamedImports(
  namedImports: Array<{ name: string; isType?: boolean }>,
  moduleName: string,
  isTypeImport: boolean
): string {
  // Formatter les imports en préservant les préfixes "type" individuels
  const formattedItems = namedImports.map(spec => {
    const typePrefix = (spec.isType || isTypeImport) ? 'type ' : '';
    return `${typePrefix}${spec.name.trim()}`;
  });

  // Filtrer les éléments vides
  const cleanedItems = formattedItems.filter(item => item.trim() !== '');

  if (cleanedItems.length === 1) {
    return `import { ${cleanedItems[0]} } from '${moduleName}';`;
  } else {
    return `import {
    ${cleanedItems.join(',\n    ')}
} from '${moduleName}';`;
  }
}

function formatDefaultAndNamedImports(
  defaultSpec: { name: string; isType?: boolean },
  namedImports: Array<{ name: string; isType?: boolean }>,
  moduleName: string,
  isTypeImport: boolean
): string {
  // Format default import
  const defaultImport = formatDefaultImport(defaultSpec, moduleName, isTypeImport);

  // Format named imports
  const namedImport = formatNamedImports(namedImports, moduleName, isTypeImport);

  // Return both imports as separate statements
  return `${defaultImport}\n${namedImport}`;
}

function formatImportItem(
  importItem: ImportSpecifier,
  statements: string[]
): void {
  const {
    source: moduleName,
    specifiers,
    type
  } = importItem;

  // Si aucun nom d'import, c'est un import de module simple (side-effect import)
  if (type === 'sideEffect' || specifiers.length === 0) {
    statements.push(formatSimpleImport(moduleName));
    return;
  }

  const isTypeImport = type === 'typeDefault' || type === 'typeNamed';
  const isDefaultImport = type === 'default' || type === 'typeDefault';
  const isNamedImport = type === 'named' || type === 'typeNamed';
  const hasNamedImports = isNamedImport || (specifiers.length > 1 && isDefaultImport);

  // Filtrer et trier les imports nommés
  const namedImports = hasNamedImports
    ? (isDefaultImport ? specifiers.slice(1) : specifiers)
    : [];

  // Import par défaut uniquement
  if (isDefaultImport && namedImports.length === 0) {
    const defaultSpec = specifiers[0];
    statements.push(formatDefaultImport(defaultSpec, moduleName, isTypeImport));
    return;
  }

  // Tri par longueur des noms d'import
  const sortedNamedImports = sortImportNamesByLength(namedImports);

  // Import par défaut ET imports nommés
  if (isDefaultImport && namedImports.length > 0) {
    const defaultSpec = specifiers[0];
    statements.push(formatDefaultAndNamedImports(
      defaultSpec,
      sortedNamedImports,
      moduleName,
      isTypeImport
    ));
  }
  // Uniquement des imports nommés
  else if (namedImports.length > 0) {
    statements.push(formatNamedImports(sortedNamedImports, moduleName, isTypeImport));
  }
}

function sortImportsInGroup(imports: ImportSpecifier[]): ImportSpecifier[] {
  return imports.sort((a, b) => {
    // First sort side-effect imports to the top
    const aIsSideEffect = a.type === 'sideEffect' || a.specifiers.length === 0;
    const bIsSideEffect = b.type === 'sideEffect' || b.specifiers.length === 0;

    if (aIsSideEffect && !bIsSideEffect) return -1;
    if (!aIsSideEffect && bIsSideEffect) return 1;

    // Order: default > named > type default > type named
    const aIsReact = a.source === 'react';
    const bIsReact = b.source === 'react';

    // Handle React imports first
    if (aIsReact && !bIsReact) return -1;
    if (!aIsReact && bIsReact) return 1;

    if (aIsReact && bIsReact) {
      // 1. Default imports (non-type)
      if (a.type === 'default' && b.type !== 'default') return -1;
      if (b.type === 'default' && a.type !== 'default') return 1;

      // 2. Named imports (non-type)
      if (a.type === 'named' && b.type !== 'named') return -1;
      if (b.type === 'named' && a.type !== 'named') return 1;

      // 3. Type default imports
      if (a.type === 'typeDefault' && b.type !== 'typeDefault') return -1;
      if (b.type === 'typeDefault' && a.type !== 'typeDefault') return 1;

      // 4. Type named imports
      if (a.type === 'typeNamed' && b.type !== 'typeNamed') return -1;
      if (b.type === 'typeNamed' && a.type !== 'typeNamed') return 1;
    }

    // For non-React modules, sort by module name
    if (a.source !== b.source) {
      return a.source.localeCompare(b.source);
    }

    // Within the same module type, sort by type (non-type first)
    const aIsType = a.type === 'typeDefault' || a.type === 'typeNamed';
    const bIsType = b.type === 'typeDefault' || b.type === 'typeNamed';
    if (aIsType !== bIsType) {
      return aIsType ? 1 : -1;
    }

    // Sort by effective length for imports of the same type
    const aLength = getEffectiveLengthForSorting(a);
    const bLength = getEffectiveLengthForSorting(b);
    return bLength - aLength;
  });
}

function generateFormattedImports(
  parsedImports: ParsedImports,
  config: FormatterConfig = configManager.getFormatterConfig()
): string {
  // Ordre défini des groupes d'imports
  const configGroups = [...config.importGroups]
    .sort((a, b) => a.order - b.order)
    .map((group) => group.name);

  const preferredOrderMap: Map<string, number> = new Map();
  configGroups.forEach((name, index) => {
    preferredOrderMap.set(name, index);
  });

  // Trier les groupes selon l'ordre défini
  const sortedGroups = [...parsedImports.groups].sort((a, b) => {
    const indexA = preferredOrderMap.has(a.name)
      ? preferredOrderMap.get(a.name)!
      : Infinity;
    const indexB = preferredOrderMap.has(b.name)
      ? preferredOrderMap.get(b.name)!
      : Infinity;

    // Si les deux groupes sont dans l'ordre préféré
    if (indexA !== Infinity && indexB !== Infinity) {
      return indexA - indexB;
    }

    // Si seulement un groupe est dans l'ordre préféré
    if (indexA !== Infinity) {
      return -1;
    }
    if (indexB !== Infinity) {
      return 1;
    }

    // Fallback sur l'ordre des groupes dans la configuration
    return a.order - b.order;
  });

  const formattedGroups: FormattedImportGroup[] = [];

  for (const group of sortedGroups) {
    if (group.imports.length === 0) {
      continue;
    }

    const groupResult: FormattedImportGroup = {
      groupName: group.name,
      commentLine: `// ${group.name}`,
      importLines: [],
    };

    const sortedImports = sortImportsInGroup(group.imports);

    for (const importItem of sortedImports) {
      const formattedLines: string[] = [];
      formatImportItem(importItem, formattedLines);
      groupResult.importLines.push(...formattedLines);
    }

    formattedGroups.push(groupResult);
  }

  // Utiliser la fonction d'alignement par section avec la configuration
  const alignedLines = alignImportsBySection(formattedGroups, config);

  return alignedLines.join('\n');
}

export function formatImports(
  parsedImports: ParsedImports,
  config: FormatterConfig = configManager.getFormatterConfig()
): string {
  config.importGroups = configManager.getImportGroups();
  config.alignmentSpacing = configManager.getAlignmentSpacing();

  // Enregistrer les sous-dossiers d'application
  for (const group of parsedImports.groups) {
    for (const importItem of group.imports) {
      if (importItem.appSubfolder) {
        configManager.registerAppSubfolder(importItem.appSubfolder);
      }
    }
  }

  // Générer le texte formaté
  return generateFormattedImports(parsedImports, config);
}
